<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Calvin Korver</title>
	<link rel="stylesheet" href="assets/css/main.css" />
	<link rel="stylesheet" href="assets/css/styles.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

	<script src="functions.js"></script>
</head>

<body>
	<div class="container full-height">
		<div class="row aln-left">
			<div class="col-12">
				<div class="header-div align-left">
					<h1> Nice to meet you, <br/>I'm <span class="yellow-color">Calvin.</span>  
						
					</h1>
				</div>
			</div>
		</div>

		<div class="row aln-left">
			<div class="col-12">
				<p class="align-left">
				<span class="emoji">&#128509;</span>Living and working in NYC.
			</p>
			</div>
		</div>



		<div class="row aln-left">
			<div class="col-12">
				<p class="align-left">

					<span class="">&#128187;
					</span>Software engineer at <a href="https://www.clearme.com/">CLEAR</a> building out backend systems
				</p>
			</div>
		</div>

		<div class="row aln-left">
			<div class="col-12">
				<p class="align-left">
					<span class="">&#x2615;</span> 
					Searching for the best coffee in the city (or skiing if I'm lucky)
					</p> 
			</div>
		</div>

		
		<p class="centered align-left">
			
		</p>

	
	
		<div class="button-container">
			<a class="link button" href="https://www.linkedin.com/in/calvinkorver/">
				<button class="material-button yellow-background">
					<!-- <span class="fa-button-span">
						<svg id='linkedin-svg-image' xmlns="http://www.w3.org/2000/svg" height="1em"
							viewBox="0 0 448 512">
							<style>
								svg {
									fill: #ffffff
								}
							</style>
							<path
								d="M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z" />
						</svg>
					</span> -->
					<span class="light-black-color">
						Linkedin
					</span>
				</button>
			</a>

			<a class="link button" onclick="scrollToDiv('projects-anchor')">

				<button class="material-button yellow-background ">
					<!-- <span class="fa-button-span">
						<i class="fa fa-hammer"></i>
					</span> -->
					<span class="light-black-color">Projects</span>

				</button>
			</a>
		</div>
	</div>
</div>
	<div id="projects-anchor" class="projects-div off-white-background">
		<div class="projects">
			<header id="header">
				<h1>Projects</h1>
				<p>Some recent projects that I've worked on...</p>
			</header>


			<section id="time-anomalies" class="project-content">
				<h2 class="project-title">Time Anomalies | Workday</h2>
				<div class="tools-frameworks">
					<span class="tools strong">Tools & frameworks:</span>
					<p> Jupyter, Xpresso (Java-based OOP language)</p>
				</div>
				<span class="strong">
					Overview
				</span>
				<p>Millions of users enter hourly time during their shift every week using time management software. While most of the data entered reflects the actual worked time, users can make mistakes. Once time is submitted, managers and timekeepers need to spend considerable time verifying user input before the time is processed for payroll.<sup class="footnote">1</sup>
					<br>
					<br>
					As part of the Time and Scheduling Hub for managers, Workday Time Anomalies automatically reveals possible time-entry errors and alerts managers about unusual time entries. The goal is to save time and improve payroll and labor cost accuracy.<sup class="footnote">2</sup>
					<br>
					<br>
					At Workday, I built out components of the cross-team Time Anomalies project that allows managers to detect these unusual time entries using machine learning. I also worked to enhance the delivery of this information to users with the Time Approval Summary filters, which allows managers and supervisors to easily discern and sort through descrepancies with their worker's time. 
					<br>
					<br>
					I deployed the feature through an early adopter phase of 10 customer opt-ins that ultimately scaled to general availability for all Time Tracking customers in Workday 2021.
					<br>
					<br>
					<span class="strong">
						Information & details
					</span>
					<br>
				
								1. <a href="https://www.workday.com/en-us/products/workforce-management/time.html">Workday Time Management</a>
							
							<br>
								2. <a href="https://blog.workday.com/en-us/2023/workforce-management-what-know-when-choosing-wfm-solution.html#:~:text=Time%20anomalies%3A%20As%20part%20of,payroll%20and%20labor%20cost%20accuracy">Workday Payroll & Time Blog Post</a>
							
	
					<img id="time-management" src="images/time-management.png" alt="">
				</p>
			</section>

			<section id="job-matcher="project-content">
				<h2 class="project-title">Job Matcher | Project</h2>
				<div class="tools-frameworks">
					<span class="tools strong">Tools & frameworks:</span>
					<p> Python, NLP, SpaCy, Scrapy, AWS Ec2</p>
				</div>

				<span class="strong">
					Overview
				</span>
				<p>Create a natural language processing model that matched user resumes with jobs and delivered a daily ranked list of prospective jobs postings.</p>
				<span class="strong">
					Lessons Learned / Challenges
				</span>
				<ul>
					<li class="lessons-learned">Balancing performance and functionality: The job scraping and matching for users involved compute-intensive operations due to the ML model. Using serverless asychronous data processing could not only alleviate server load but could also improve user experience.</li>
					<li class="lessons-learned">Optimizing the database: A NoSQL database would allow us to quickly update new jobs with flexibility to change our schema as we prototyped.</li>
					<li class="lessons-learned">Tuning the algorithm: We could stack programatic rules with the machine learning algorithm to deliver more accurate predictionos.
				</ul>
				<span class="strong">
					Details
				</span>
				<p>This project was inspired by a friend who came to me with a problem. Recently laid off from a large
					Seattle-area tech company, he was looking for a new job.
					While there were many services to help find jobs, finding a good match with unique skills and
					experiences required many hours manually parsing job descriptions for a good fit.
					<br>
					<br>
					What if there was a service that could process and match your resume with related jobs and deliver a ranked list of results daily to aid your job search?
					<br>
					<br>
					With that idea in mind, we worked together to create Job Matcher, a service that scrapes job posting
					websites and uses natural language processing to compute similarities between the postings and user
					resumes. It would prioritize skills (for example, Ruby or AWS Sagemaker) and return to the user a
					set of matched jobs ranked by the machine learning model's scoring criteria daily. The job
					position scraping and matching would be automated via a daily asyncronous API call to an EC2 instance or using a Lambda function so by the time
					the user logged in, the results would already be persisted and presented to them on the client side.
				</p>
				<span class="strong">
					Architecture
				</span>	

				<p id="last-job-finder">The application consists of several main components: The flask server handles the client interaction including user identification and metadata persistence (resume, email, etc.). To communicate with the MongoDB cluster, we exposed pathways via FastAPI to allow for new user creation, updating of user details, and getting the latest matched resumes. Depending on which API pathway is called, we utilize the SpaCy NLP library to look for skills in the jobs and calculate semantic similarity with the user's information.</p>
				<div class="image-container">
					<img id='job-finder-img' src="/images/JobFinder.png" alt="">
				</div>
				<p>One particular difficult aspect of the project was determining when the job scraping and matching would run. Since the application needed to not only scrape jobs and match them with the user's data, the user might have to wait a long time to see their results if we performed these actions syncronously. </p>
				<p>For future improvements, we could utilize a server-less service like Amazon Lambda that could be triggered daily to run the scraper and matcher. Additionally, Lambda Layers allows multiple dependencies like SpaCy and PyScraper to be incorporated easily into the deployed Lambda function. Consequently, dependencies can be managed with rewriting the Docker script and if we wanted to improve the algorithm in the future with new functionality, new packages could be added.</p>
				
				
			</section>
		</div>
	</div>
	<footer class="footer">
		<p>Much of this website was created using a generative model (GPT-3.5) <i class="far fa-smile"></i>
		</p>
	</footer>
</body>

</html>